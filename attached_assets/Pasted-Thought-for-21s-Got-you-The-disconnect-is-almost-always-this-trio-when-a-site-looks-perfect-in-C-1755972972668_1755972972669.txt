Thought for 21s

Got you. The “disconnect” is almost always this trio when a site looks perfect in Chrome mobile but wrong inside your Android app’s WebView:

the WebView isn’t honoring the viewport the same way a normal browser does,

you have JS/UA sniffing that forces a layout instead of letting CSS breakpoints do the job, and/or

Tailwind breakpoints (or a custom screens config) don’t line up with the CSS pixels your WebView is actually reporting.

Here’s a straight-shot fix that covers all three—do these exactly and you’ll get the same responsive behavior as your deployed site.

1) Use the correct viewport (index.html)

In client/index.html, make the viewport exactly this and remove any maximum-scale, minimum-scale, or user-scalable flags:

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">


Why: Android WebView can behave like a 980-px “wide viewport” if the meta is missing/overridden, which tricks Tailwind into thinking it’s desktop.

2) Remove any layout forcing via JS / UA sniffing

Delete any code that sets a “mobile” or “desktop” class based on navigator.userAgent, wv, or “Android WebView”. Let CSS breakpoints decide.

Common culprits to remove:

// ❌ remove things like this
if (isAndroid && isWebView) {
  document.documentElement.classList.add("mobile");
}

3) Tailwind should do all the deciding

If you customized Tailwind screens, keep them normal. Example:

// tailwind.config.js
module.exports = {
  theme: {
    extend: {},
    screens: {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px",
      "2xl": "1536px",
    },
  }
}


Avoid tiny custom breakpoints that might make your “desktop-mobile” layout never trigger inside WebView.

4) Set the WebView correctly (Android code)

In your Android wrapper (Kotlin/Java), set these flags so the viewport meta is respected and the page scales like a real mobile browser:

Kotlin

webView.settings.apply {
    javaScriptEnabled = true
    domStorageEnabled = true

    // Respect meta viewport and let CSS pixels match device width
    useWideViewPort = true
    loadWithOverviewMode = true

    // Don’t zoom; let your responsive CSS handle layout
    builtInZoomControls = false
    displayZoomControls = false

    // Optional: make sure UA isn’t “desktop”
    userAgentString = userAgentString.replace("wv", "wv Mobile")
}


Java

WebSettings s = webView.getSettings();
s.setJavaScriptEnabled(true);
s.setDomStorageEnabled(true);
s.setUseWideViewPort(true);
s.setLoadWithOverviewMode(true);
s.setBuiltInZoomControls(false);
s.setDisplayZoomControls(false);
s.setUserAgentString(s.getUserAgentString().replace("wv", "wv Mobile"));


Notes:

useWideViewPort=true + correct meta viewport makes the layout width match device width (so Tailwind md, lg, etc. fire correctly).

If you previously forced a “desktop UA” anywhere, undo it.

5) Make sure your CSS isn’t overriding the viewport

Double-check you don’t have global CSS like:

/* ❌ avoid */
html, body { min-width: 1024px; }


That would lock the layout to desktop width.

6) One quick sanity check in the app (no debugger needed)

Add a tiny banner in dev builds (and then remove later) to see what the WebView thinks the width is:

<div id="vw-debug" style="position:fixed;bottom:8px;right:8px;padding:6px 10px;font:12px/1.2 system-ui;background:#0008;color:#fff;border-radius:8px;z-index:99999"></div>
<script>
  const el = document.getElementById('vw-debug');
  if (el) {
    const update = () => el.textContent = `w:${window.innerWidth}px dpr:${window.devicePixelRatio}`;
    update();
    window.addEventListener('resize', update);
  }
</script>


If you see something like w:980px, the viewport/meta/WebView flags weren’t applied; with the fixes above you should see a “real” mobile width (e.g., 360–430 CSS px depending on device).